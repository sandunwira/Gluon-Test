<body>
  <div id="log"></div>
  <div id="store"></div>
  <div id="expose"></div>
  <div id="latency"></div>

  <script> (async () => {
    await new Promise(res => {
      const check = () => {
        if (!window.Gluon) return setTimeout(check, 100);
        res();
      };

      check();
    });

    window.Gluon.ipc.on('test', msg => log.innerHTML += `${msg}<br>`);
    window.Gluon.ipc.send('web');

    store.innerText = 'store: ' + JSON.stringify(window.Gluon.ipc.store);

    expose.innerText = 'expose returned: ' + await window.Gluon.ipc.wow();

    const exposeNano = async () => BigInt(await Gluon.ipc.now());
    const eventNano = async () => BigInt(await Gluon.ipc.send('event now'));

    const analyze = async (func, runs = 10) => {
      let sum = 0, min = Number.MAX_VALUE, max = Number.MIN_VALUE;
      for (let i = 0; i < runs; i++) {
        const result = await func();
        sum += result;

        if (result > max) max = result;
        if (result < min) min = result;
      }

      const format = n => `${n.toFixed(5)}ms`;

      const stats = {
        mean: sum / runs,
        min,
        max
      };

      return Object.keys(stats).map(x => `${x}: ${format(stats[x])}`).join(', ');
    };

    const measureLatencies = async () => {
      const exposeDiff = async () => {
        const t2 = await exposeNano();
        const t3 = await exposeNano();

        return Number(t3 - t2) / 1000000; // ns -> ms
      };

      const exposeRoundTrip = async () => {
        const t0 = performance.now();
        await window.Gluon.ipc.noop();
        const t1 = performance.now();
        return t1 - t0;
      };

      const eventDiff = async () => {
        const t2 = await eventNano();
        const t3 = await eventNano();

        return Number(t3 - t2) / 1000000; // ns -> ms
      };

      const eventRoundTrip = async () => {
        const t0 = performance.now();
        await window.Gluon.ipc.send('event noop');
        const t1 = performance.now();
        return t1 - t0;
      };

      const latencies = {};
      latencies.exposeRoundTrip = await analyze(exposeRoundTrip, 1000);
      latencies.exposeDiff = await analyze(exposeDiff, 1000);
      latencies.eventRoundTrip = await analyze(eventRoundTrip, 1000);
      latencies.eventDiff = await analyze(eventDiff, 1000);

      latency.innerHTML = `<br>latency:<br>` + Object.keys(latencies).map(x => `${x}: ${latencies[x]}`).join('<br>');
    };
    measureLatencies();

    setInterval(measureLatencies, 4000);
  })(); </script>
</body>